(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.HTMLDOMParser = factory());
}(this, (function () { 'use strict';

  /**
   * SVG elements are case-sensitive.
   *
   * @see {@link https://developer.mozilla.org/docs/Web/SVG/Element#SVG_elements_A_to_Z}
   */
  var CASE_SENSITIVE_TAG_NAMES = [
    'animateMotion',
    'animateTransform',
    'clipPath',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussainBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotLight',
    'feTile',
    'feTurbulence',
    'foreignObject',
    'linearGradient',
    'radialGradient',
    'textPath'
  ];

  var constants = {
    CASE_SENSITIVE_TAG_NAMES: CASE_SENSITIVE_TAG_NAMES
  };

  var CASE_SENSITIVE_TAG_NAMES$1 = constants.CASE_SENSITIVE_TAG_NAMES;

  var caseSensitiveTagNamesMap = {};
  var tagName;
  for (var i = 0, len = CASE_SENSITIVE_TAG_NAMES$1.length; i < len; i++) {
    tagName = CASE_SENSITIVE_TAG_NAMES$1[i];
    caseSensitiveTagNamesMap[tagName.toLowerCase()] = tagName;
  }

  /**
   * Gets case-sensitive tag name.
   *
   * @param  {String}           tagName - The lowercase tag name.
   * @return {String|undefined}
   */
  function getCaseSensitiveTagName(tagName) {
    return caseSensitiveTagNamesMap[tagName];
  }

  /**
   * Formats DOM attributes to a hash map.
   *
   * @param  {NamedNodeMap} attributes - The list of attributes.
   * @return {Object}                  - A map of attribute name to value.
   */
  function formatAttributes(attributes) {
    var result = {};
    var attribute;
    // `NamedNodeMap` is array-like
    for (var i = 0, len = attributes.length; i < len; i++) {
      attribute = attributes[i];
      result[attribute.name] = attribute.value;
    }
    return result;
  }

  /**
   * Corrects the tag name if it is case-sensitive (SVG).
   * Otherwise, returns the lowercase tag name (HTML).
   *
   * @param  {String} tagName - The lowercase tag name.
   * @return {String}         - The formatted tag name.
   */
  function formatTagName(tagName) {
    tagName = tagName.toLowerCase();
    var caseSensitiveTagName = getCaseSensitiveTagName(tagName);
    if (caseSensitiveTagName) {
      return caseSensitiveTagName;
    }
    return tagName;
  }

  /**
   * Formats the browser DOM nodes to mimic the output of `htmlparser2.parseDOM()`.
   *
   * @param  {NodeList} nodes        - The DOM nodes.
   * @param  {Object}   [parentObj]  - The formatted parent node.
   * @param  {String}   [directive]  - The directive.
   * @return {Object[]}              - The formatted DOM object.
   */
  function formatDOM(nodes, parentObj, directive) {
    parentObj = parentObj || null;

    var result = [];
    var node;
    var prevNode;
    var nodeObj;

    // `NodeList` is array-like
    for (var i = 0, len = nodes.length; i < len; i++) {
      node = nodes[i];
      // reset
      nodeObj = {
        next: null,
        prev: result[i - 1] || null,
        parent: parentObj
      };

      // set the next node for the previous node (if applicable)
      prevNode = result[i - 1];
      if (prevNode) {
        prevNode.next = nodeObj;
      }

      // set the node name if it's not "#text" or "#comment"
      // e.g., "div"
      if (node.nodeName[0] !== '#') {
        nodeObj.name = formatTagName(node.nodeName);
        // also, nodes of type "tag" have "attribs"
        nodeObj.attribs = {}; // default
        if (node.attributes && node.attributes.length) {
          nodeObj.attribs = formatAttributes(node.attributes);
        }
      }

      // set the node type
      // e.g., "tag"
      switch (node.nodeType) {
        // 1 = element
        case 1:
          if (nodeObj.name === 'script' || nodeObj.name === 'style') {
            nodeObj.type = nodeObj.name;
          } else {
            nodeObj.type = 'tag';
          }
          // recursively format the children
          nodeObj.children = formatDOM(node.childNodes, nodeObj);
          break;
        // 2 = attribute
        // 3 = text
        case 3:
          nodeObj.type = 'text';
          nodeObj.data = node.nodeValue;
          break;
        // 8 = comment
        case 8:
          nodeObj.type = 'comment';
          nodeObj.data = node.nodeValue;
          break;
      }

      result.push(nodeObj);
    }

    if (directive) {
      result.unshift({
        name: directive.substring(0, directive.indexOf(' ')).toLowerCase(),
        data: directive,
        type: 'directive',
        next: result[0] ? result[0] : null,
        prev: null,
        parent: parentObj
      });

      if (result[1]) {
        result[1].prev = result[0];
      }
    }

    return result;
  }

  /**
   * Detects IE with or without version.
   *
   * @param  {Number}  [version] - The IE version to detect.
   * @return {Boolean}           - Whether IE or the version has been detected.
   */
  function isIE(version) {
    if (version) {
      return document.documentMode === version;
    }
    return /(MSIE |Trident\/|Edge\/)/.test(navigator.userAgent);
  }

  var utilities = {
    formatAttributes: formatAttributes,
    formatDOM: formatDOM,
    isIE: isIE
  };

  // constants
  var HTML = 'html';
  var HEAD = 'head';
  var BODY = 'body';
  var FIRST_TAG_REGEX = /<([a-zA-Z]+[0-9]?)/; // e.g., <h1>
  var HEAD_TAG_REGEX = /<head.*>/i;
  var BODY_TAG_REGEX = /<body.*>/i;
  // http://www.w3.org/TR/html/syntax.html#void-elements
  var VOID_ELEMENTS_REGEX = /<(area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)(.*?)\/?>/gi;

  // detect IE browser
  var isIE9 = utilities.isIE(9);
  var isIE$1 = isIE9 || utilities.isIE();

  // falls back to `parseFromString` if `createHTMLDocument` cannot be used
  var parseFromDocument = function () {
    throw new Error(
      'This browser does not support `document.implementation.createHTMLDocument`'
    );
  };

  var parseFromString = function () {
    throw new Error(
      'This browser does not support `DOMParser.prototype.parseFromString`'
    );
  };

  /**
   * DOMParser (performance: slow).
   *
   * @see https://developer.mozilla.org/docs/Web/API/DOMParser#Parsing_an_SVG_or_HTML_document
   */
  if (typeof window.DOMParser === 'function') {
    var domParser = new window.DOMParser();

    // IE9 does not support 'text/html' MIME type
    // https://msdn.microsoft.com/en-us/library/ff975278(v=vs.85).aspx
    var mimeType = isIE9 ? 'text/xml' : 'text/html';

    /**
     * Creates an HTML document using `DOMParser.parseFromString`.
     *
     * @param  {string} html      - The HTML string.
     * @param  {string} [tagName] - The element to render the HTML (with 'body' as fallback).
     * @return {HTMLDocument}
     */
    parseFromString = function (html, tagName) {
      if (tagName) {
        html = '<' + tagName + '>' + html + '</' + tagName + '>';
      }

      // because IE9 only supports MIME type 'text/xml', void elements need to be self-closed
      if (isIE9) {
        html = html.replace(VOID_ELEMENTS_REGEX, '<$1$2$3/>');
      }

      return domParser.parseFromString(html, mimeType);
    };

    parseFromDocument = parseFromString;
  }

  /**
   * DOMImplementation (performance: fair).
   *
   * @see https://developer.mozilla.org/docs/Web/API/DOMImplementation/createHTMLDocument
   */
  if (document.implementation) {
    // title parameter is required in IE
    // https://msdn.microsoft.com/en-us/library/ff975457(v=vs.85).aspx
    var doc = document.implementation.createHTMLDocument(
      isIE$1 ? 'html-dom-parser' : undefined
    );

    /**
     * Use HTML document created by `document.implementation.createHTMLDocument`.
     *
     * @param  {string} html      - The HTML string.
     * @param  {string} [tagName] - The element to render the HTML (with 'body' as fallback).
     * @return {HTMLDocument}
     */
    parseFromDocument = function (html, tagName) {
      if (tagName) {
        doc.documentElement.getElementsByTagName(tagName)[0].innerHTML = html;
        return doc;
      }

      try {
        doc.documentElement.innerHTML = html;
        return doc;
        // fallback when certain elements in `documentElement` are read-only (IE9)
      } catch (err) {
        if (parseFromString) {
          return parseFromString(html);
        }
      }
    };
  }

  /**
   * Template (performance: fast).
   *
   * @see https://developer.mozilla.org/docs/Web/HTML/Element/template
   */
  var template = document.createElement('template');
  var parseFromTemplate;

  if (template.content) {
    /**
     * Uses a template element (content fragment) to parse HTML.
     *
     * @param  {string} html - The HTML string.
     * @return {NodeList}
     */
    parseFromTemplate = function (html) {
      template.innerHTML = html;
      return template.content.childNodes;
    };
  }

  /**
   * Parses HTML string to DOM nodes.
   *
   * @param  {string} html - The HTML string.
   * @return {NodeList|Array}
   */
  function domparser(html) {
    var firstTagName;
    var match = html.match(FIRST_TAG_REGEX);

    if (match && match[1]) {
      firstTagName = match[1].toLowerCase();
    }

    var doc;
    var element;
    var elements;

    switch (firstTagName) {
      case HTML:
        doc = parseFromString(html);

        // the created document may come with filler head/body elements,
        // so make sure to remove them if they don't actually exist
        if (!HEAD_TAG_REGEX.test(html)) {
          element = doc.getElementsByTagName(HEAD)[0];
          if (element) {
            element.parentNode.removeChild(element);
          }
        }

        if (!BODY_TAG_REGEX.test(html)) {
          element = doc.getElementsByTagName(BODY)[0];
          if (element) {
            element.parentNode.removeChild(element);
          }
        }

        return doc.getElementsByTagName(HTML);

      case HEAD:
      case BODY:
        elements = parseFromDocument(html).getElementsByTagName(firstTagName);

        // if there's a sibling element, then return both elements
        if (BODY_TAG_REGEX.test(html) && HEAD_TAG_REGEX.test(html)) {
          return elements[0].parentNode.childNodes;
        }
        return elements;

      // low-level tag or text
      default:
        if (parseFromTemplate) {
          return parseFromTemplate(html);
        }

        return parseFromDocument(html, BODY).getElementsByTagName(BODY)[0]
          .childNodes;
    }
  }

  var domparser_1 = domparser;

  var formatDOM$1 = utilities.formatDOM;
  var isIE9$1 = utilities.isIE(9);

  var DIRECTIVE_REGEX = /<(![a-zA-Z\s]+)>/; // e.g., <!doctype html>

  /**
   * Parses HTML and reformats DOM nodes output.
   *
   * @param  {String} html - The HTML string.
   * @return {Array}       - The formatted DOM nodes.
   */
  function parseDOM(html) {
    if (typeof html !== 'string') {
      throw new TypeError('First argument must be a string');
    }

    if (!html) {
      return [];
    }

    // match directive
    var match = html.match(DIRECTIVE_REGEX);
    var directive;

    if (match && match[1]) {
      directive = match[1];

      // remove directive in IE9 because DOMParser uses
      // MIME type 'text/xml' instead of 'text/html'
      if (isIE9$1) {
        html = html.replace(match[0], '');
      }
    }

    return formatDOM$1(domparser_1(html), null, directive);
  }

  var htmlToDomClient = parseDOM;

  return htmlToDomClient;

})));
//# sourceMappingURL=html-dom-parser.js.map
